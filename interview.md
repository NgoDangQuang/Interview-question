# A. THÔNG TIN CHUNG

### Câu 1: Giới thiệu bản thân

- Tên tuổi: Ngô Đăng Quang - 22 Tuổi
- Sinh viên Đại học khoa học Tự Nhiên, Khoa Công Nghệ Thông Tin
- Sở thích: Yêu thích các môn thể thao vận động mạnh như bóng chuyền, đá bóng và võ thuật. Ngoài ra em cũng yêu thích code web Frontend tại vì em có thể tạo ra những sản phẩm đẹp theo ý thích của bản thân.
- Định hướng làm việc của em: Trong thời gian tới em sẽ làm thiên về Frontend Development, tương lai xa hơn em muốn trở thành một Fullstack Development

### Câu 2: Tại sao lại muốn apply vào công ty này?

- Em biết GEEK Up là một công ty chuyên làm Product, là một products partner với những doanh nghiệp lớn như VP Bank, Viettel, Elsa và các công ty nước ngoài nữa.
- Công ty cũng thành lập được khoảng 9 năm, nhưng mang tinh thần của một start up, và một công ty start up sẽ giúp em học được nhiều hơn là những công ty OutSource.
- Ở GEEK Up hoạt động theo mô hình Flag, không phân cấp nên trong quá trình làm việc mọi người có thể thoải mái hơn, giúp luyện kỹ năng Self management tốt nhất.
- Em cũng đã có một khoảng thời gian là 10 tuần để thực tập tại công ty, em yêu thích con người và môi trường làm việc ở đây. Nên em muốn apply vào công ty để được làm việc cùng với mọi người ở đây.

### Câu 3: Em apply vào vị trí JS, React thì em làm JS được bao lâu rồi?

- Em bắt đầu học về Javascript và React khoảng từ đầu năm nay.

# B. HTML / CSS

### Câu 1: Đã từng làm việc với HTML, CSS rồi thì em có biết cấu trúc của 1 trang HTML gồm những gì và ý nghĩa như thế nào không?

- Cấu trúc của 1 trang html sẽ có 3 phần

* phần 1: DOCTYPE : sẽ khai báo chuẩn của HTML hay là XTML
* phần 2: Thẻ HEAD : sẽ khai báo ban đầu thường sẽ khai báo về thẻ META, TITLE, CSS, JAVASCRIPT
* phần 3: Thẻ BODY: phần này sẽ là nơi chứa nội dung của trang web, nơi hiển thị nội dung

### Câu 2: So sánh thuộc tính Class và ID trong HTML?

- Giống: Dùng để đặt tên và phân loại các phần tử, mục đích là để tiện cho việc quản lý và định dạng xử lí các phần tử sau này.
- ID: là duy nhất thường sẽ sử dụng trong form đê xử lý dữ liệu input của người dùng hoặc làm hiệu ứng cho thẻ
- Class: cũng tương tự như ID nhưng mình có thể đặt nhiều class giống nhau, đặc điểm là các class này sẽ có những định dạng css giống nhau.

### Câu 3: Trong CSS có một định nghĩa là Selector, em có nghe qua chưa?

- CSS selector thì nó giống như là một con trỏ trong css để chỉ định ra những thẻ mình muốn định dạng hoặc là tạo kiểu trong HTML.
- Có một số loại Selector cơ bản như sau:

* Simple selector: id, class, name
* Combinator selector: div > p {}, div p{}
* Pseudo-class selector: a:link , a:hover, a:active
* Pseudo-element selecttor: p::first-letter, p::first-line, p:before , p::after
* Atribute selector: a[target], a[target="_blank"] , [class^="top"]

### Câu 4: Một khái niệm quan trọng trong lập trình frontend là Box Model. Hãy giới thiệu về nó?

- Mỗi phần tử trong trang web đều có một khối hình chữ nhật riêng. Box Model là khoảng không gian phần tử đó chiếm trong trang web.
- Box Model bao gồm 4 thành phần chính:

* Content: là nội dung của phần tử
* Border: là đường viền của hình chữ nhật
* Padding: là khoảng đệm, là khoảng cách từ content tới border.
* Margin: là cái lề được tính từ border của phần tử này đến border của phần tử khác

### Câu 5: Display Block , Display Inline, Display Inline-Block là gì? Khác nhau như thế nào?

- Display Block: các item sẽ chiếm toàn bộ chiều rộng nếu chúng không được set chiều rộng (vd thẻ div). Đặc điểm là có thể set width, height, padding, margin đầy đủ 4 hướng
- Display Inline: các item cùng nằm trên cùng 1 dòng (vd như thẻ span), nếu độ dài quá dài thì nó sẽ xuống 1 dòng mới, đặc điểm là chúng không thể setWidth cũng như setHeight cho nó. Chỉ có thể điều chỉnh margin, padding Left Right ( Top và Bottom thì không thể chỉnh ).
- Display Inline-Block: sẽ được sắp xếp giống display: inline, nghĩa là các items sẽ được xép cùng nhau trên một dòng. Tuy nhiên các items này sẽ có thuộc tính của display:block đó là set width, height, margin, padding theo cả 4 hướng.

# C. JAVASCRIPT

### Câu 1. Javascript là gì? JS chạy được ở đâu, Fontend hay Backend?

- Javascript là một ngôn ngữ lập trình phổ biến nhất trên thế giới. Nó là một trong số 3 ngôn ngữ chính của lập trình web.

* HTML: Giúp bạn thêm nội dung cho trang web
* CSS: Định dạng thiết kế, bố cục , phong cách, canh lề của trang web.
* Javascript: Cải thiện cách họa động của trang web.

- Javascript được sử dụng trên nền tảng phát triển web. Nó vừa là giao diện người dùng vừa là backend

### Câu 1.b: Frontend là gì? Backend là gì? Fullstack là gì?

- Frontend là phần hiển thị của một trang web bao gồm cả những tương tác của người dùng, các hiệu ứng, màu sắc, ...
- Backend là nơi hỗ trợ hoạt động của website hoặc ứng dụng mà người dùng không thể nhìn thấy được. Nó chứa database, các api, server , ...
- Fullstack đơn giản là công việc bao gồm cả Frontend và Backend

### Câu 2. Các kiểu dữ liệu trong Javascript?

- String, Number, Boolean, Object, Undefined, Null.

### Câu 3: Khái niệm Hoisting trong JS?

- Hoisting là cơ chế mà trình thông dịch di chuyển tất cả các biến , hàm được khai báo lên đầu mã nguồn. Bất kể phạm vi của chúng là toàn cục hay cục bộ, chúng đều được trình thông dịch đưa lên đầu trong phạm vi của chúng.
- Nói đơn giản, Hoisting chính là việc chúng ta có thể sử dụng biến rồi khai báo nó sau.

* Giá trị của biến khi khai báo var là undefined
* Giá trị let avf const vẫn được hoist nhưng nó không có giá trị nên sẽ báo lỗi Reference Error.

### Câu 4: Trong JS so sánh == và === khác nhau như thế nào?

- So sánh == được gọi là toán tử so sánh trừu tượng
- So sánh === được gọi là so sánh cân bằng nghiêm ngặt

- Toán tử so sánh trừu tượng sẽ cố gắng ép kiểu các toán hạng về dạng chung nhất sau đó mới so sánh
- Toán tử so sánh nghiêm ngặt thì sẽ không ép kiểu các toán hạng đó mà so sánh luôn.

### Câu 5. Một số phương thức xử lý mảng trong javascript?

- Concat(): nối mảng
- Filter(): Trả về tất cả các phần tử thỏa mãn điều kiện nào đó cho trước
- Find(): Tìm phần tử trong mảng dựa vào dữ liệu cho trước( 1 phần tử đầu tiên )
- ForEach(): gọi một hàm cho mỗi phần tử trong mảng
- Includes(): Tìm kiếm một phần tử có tồm tại trong mảng hay không ( true/false )
- IndexOf(): trả về chỉ mục đầu tiên của một phần tử trong mảng nếu tìm thấy, nếu không có thì trả về -1
- Join(): kết nối tất cả các phần tử trong một mảng thành một chuỗi và ngăn cách chúng bằng separator( mặc định là dấu phẩy)
- Map(): tạo một mảng mới với các kết quả của việc gọi một hàm đã cho trên mỗi phần tử của mảng này
- Pop(): Xóa phần tử ở cuối mảng và cho ra phần tử đã xóa
- Shift(): Xóa và lấy phần tử đầu mảng ra
- UnShift(): Thêm 1 hoặc nhiều phần tử và đầu mảng cho ra độ dài mới của mảng
- Push(): Thêm phần tử vào cuối mảng

### Câu 6: Sự khác nhau giữa forEach và Map?

- ForEach sẽ không trả về giá trị nào, forEach dùng hàm callback và thay đổi giá trị mảng ban đầu
- Map có trả về giá trị, map không thay đổi mảng ban đầu mà trả về một mảng mới có cùng số lượng phần tử của mảng cũ

### Câu 7: Những tính năng mới trong ES6 là gì?

- Những tính năng nổi bật trong ES6 đó là:

* let, const : Trước đây chỉ có var, từ ES6 có thêm let và const như 2 cách khai báo biến mới, hỗ trợ tầm vực theo khối (block scope) và không được hoisting
* Arrow function: Là một kiểu cú pháp rút gọn cho khai báo hàm trong Javascript
* Template string: Cúng giống như là string literals nhưng cho phép đính kèm biểu thức. Nó cũng cho phép khai báo chuỗi trên nhiều dòng. Cách dùng là sử dụng ký tự backtick ``(dấu huyền)
* Object literals: Cũng là khai báo một object như thường lệ, nhưng cho phép khai báo tắt thuộc tính của object với biến cùng tên và khai báo phương thức cho object.
* Destructuring: Giúp ta tách biến từ thuộc tính của đối tượng hay phần tử trong các đối tượng có thể duyệt với for như là mảng hoặc chuỗi.
* Rest: (Phần còn lại) là phần bổ sung của phân rã biến mảng. Rest được dùng khi khai báo hàm có thể nhận nhiều tham số.
* Spread: (Rải) là thao tác ngược lại với Rest, giúp ta kết hợp một mảng đã có sẵn thành một mảng mới. Spread rất hữu ích để thay thế các thao tác trên mảng như concat().
* Default value: Cho phép mình thiết lập giá rị mặc định cho tham số khi nó không được truyền giá trị hoặc có giá trị undefined. Thường dùng trong khi truyền giá trị vào hàm.
* Class: với ES5 chúng ta sử dụng function để tạo lớp và thêm các phương thức vào lớp bằng cách mở rộng prototype. Thì với ES6 chúng ta có cú pháp mới giúp tạo lớp trực tiếp và dễ dàng hơn. Có thể kế thừa từ lớp khác bằng từ khóa extends.
* Promises: Sinh ra để giúp chúng ta sử lý các tác vụ bất đồng bộ.

### Câu 8: Nói kỹ hơn về Promise?

- Promise sinh ra để giúp chúng ta sử lý các tác vụ bất đồng bộ
- Trước khi có promise ta thường sử dụng callback và callback xảy ra một vấn đề đó là callback hell, nó sẽ bị sâu vào gây khó nhìn, code dễ bị rối rắm, khó hiểu.
  ==> Promise được sịnh ra để khắc phục tình trạng callback hell
- Để tạo ra một Promise ta sử dụng từ khóa new với thằng Promise và trong constructor của nó ta truyền vào một executor function. Và trong executor func này sẽ nhận được hai tham số dưới dạng hàm.

  - Resolve: được gọi khi thao tác logic thành công
  - Reject : được gọi khi thao tác thất bại

- Khi chúng ta sử dụng Promise, chúng ta sẽ sử dụng 2 phương thức đó là (.then) và (.catch). Cả 2 phương thức này đều nhận callback 
    + sẽ được thực thi vào thằng then khi promise được resolve 
    + sẽ thực thi vào catch khi promise bị reject

- Promise có 3 trạng thái: 
    + Pending   : đang chờ thành công hay thất bại(rò rĩ bộ nhớ nếu nó chờ mãi)
    + Fulfilled : thành công (resolve được gọi)
    + Reject    : thất bại ( reject được gọi)

var promise = new Promise(
    funtion(resolve, reject){
        resolve(console.log('Successfully!'));
        reject('Failuer!');
    }
)

### Câu 8: So sánh giữa var, let và const ?

- var có phạm vi là function scope hoặc global scope, nó có thể gán lại và khai báo lại.
- let có phạm vi là block scope, có thể gán lại nhưng không thể khai báo lại
- const phạm vi là block scope, không thể gán lại cũng như không thể khai báo lại

### Câu 9: So sánh Function và ArrowFunction

- Arrow Func sử dụng ký hiệu là mũi tên, arrow function thường sẽ ngắn gọn hơn func bình thường
- Với hàm số có 1 tham số thì Arrow Func có thể bỏ qua dấu ngoặc đơn
- Arrow Func có thể bỏ qua từ khóa return
- Đối với Arrow func chúng ta không thể sử dụng hàm constructor, không có thuộc tính prototype, không được hoist ( tức là không thể dùng hàm trước khi khai báo )

### Câu 10: Khái niệm callback? Tại sao lại dùng callback ? Dùng trong những trường hợp nào khi code ?

- Callback là một hàm được truyền vào hàm khác dưới dạng đôi số.
- Dùng trong trường hợp một hành động bất đồng bộ, một hành động nó chưa hoàn thành xong ngay lúc nó chạy thì ta truyền callback vào để chạy ngay sau khi có kết quả
- Dùng khi tạo một event hay gì đó thì ta đưa một callback function vào để khi người dùng bấm vào một cái nút hoặc hover chuột thì nó sẽ gọi cái hàm đó

### Câu 11: Khái niệm Closures ? Dùng Closures để làm gì ?

- Là một hàm có thể ghi nhớ nơi mà nó được tạo và truy cập được biến ở bên ngoài phạm vi của nó.

### Câu 12: Nút GoToTop code như thế nào bằng js ?

- Cách 1: window.scrollTo({top:0, behavior:'smooth})
- Cách 2: const element = document.getElementById('#id')
            element.scrollIntoView({behavior:'smooth', block:'start', inline:'nearest'})

### Câu 13: Dùng JS thì làm sao để check khi nào người ta điền form thì mới cho submit form?

- Truyền callback vào hàm onSubmit , sau đó viết hàm preventDefault, dùng JS lấy các thông tin họ đã điền và check xem đúng hay không. Nếu ok thì mới submit form.

### Câu 15. Thuật toán sắp xếp nào nhanh nhất?

-> Quicksort n.log(n)

### Câu 16. Cho một mảng đã sắp xếp -> Tìm một phần tử trong mảng thì dùng thuật toán gì?

-> Binary search -> độ phức tạp là log(n)

### Câu 17. Cho một mảng bình thường -> Tìm phần tử lớn thứ 2 trong mảng

- Cách 1: Lưu 2 biến chứa phần tử lớn thứ nhất và thứ 2, mối lần duyệt thì ta sắp xếp và so sánh 2 cái biến đó.
- Cách 2: Duyệt lần 1 tìm phần tử lớn nhất sau đó remove nó ra, duyệt lần 2 thì ta sẽ có đc phần tử lớn thứ 2
- Cách 3: Sắp xếp các phần tử và lấy phần tử lớn thứ 2 ( câu này thích hơn cho tìm phần tử lớn thứ n trong mảng)

### Câu 18: Phân bệt Server-side và Client-side

- Server-side: Phần lớn logic sẽ được xử lý ở server.
    + Khi người dùng vào một trang web, trình duyệt sẽ gởi GET request tới web server.
    + Web server sẽ nhận request, đọc dữ liệu từ database.
    + Web server sẽ render HTML, trả về cho browser để hiển thị cho người dùng.
    ==> Logic từ đơn giản đến phức tạp, logic để routing, để render đều nằm ở server

    - Ưu điểm: 
        + Thân thiện với SEO vì BOT của Google hay Bing vào website sẽ thấy toàn bộ dữ liệu dưới dạng HTML. 
        + Tương thích trên rất nhiều trình duyệt khác nhau vì nó đã ra đời rất là lâu rồi. 
        + Thời gian load lần đầu tiên rất nhanh.
    - Nhược điểm: 
        + Khi nhận được request về cơ bản thì HTML đã được hiện lên nhưng chưa thể tương tác gì JS sẽ tải chậm hơn nên cần phải tải xong cả JS mới có thể tương tác được.
        + Khi chuyển trang thì web sẽ load lại toàn bộ từ đầu gây ảnh hưởng đến trải nghiệm người dùng.
        + Nếu lượng request lên server nhiều thì dễ gây chậm và quá tải
        + Tốn băng thông vì server phải gởi lại nhiều dữ liệu trùng và thừa.

- Client-side: Là việc render HTML, CSS được thực hiện ở Client (tức là Javascript ở trình duyệt)
    + Những logic đơn giản , logic routing, render nằm ở Client-side
    + Những logic phức tạp như thanh toán, phân quyền hoặc cần xử lý nhiều thì vẫn nằm ở Server-side

    - Ưu điểm:
        + Giải quyết mặt hạn chế của Server-side
        + Khi chuyển trang khá nhanh , cải thiện trải nghiệm người dùng đáng kể so với server-side
    - Nhược điểm:
        + Load lần đầu khá chậm vì để render được HTML , client phải tải JS về sau đó chạy JS để DOM và gọi API
        + Không tốt cho SEO bằng server-side vì nội dung được sinh ra ở client nên các con Bot không dễ dàng tìm kiếm và đọc được dữ liệu.

### Câu 19: Bất đồng bộ trong Javascript

- Javascript là ngôn ngữ lập trình bất đồng bộ và chỉ chạy trên một luồng. Sự bất đồng bộ trong javascript xuất hiện khi nó thao tác với các WebAPI (ajax, setTimeout(), … ). Khi một câu lệnh thao tác với WebAPI, nó sẽ mất một khoảng thời gian để chờ các dữ liệu trả về từ WebAPI, do đó ở trong luồng chính của javascript, nó sẽ ở trong trạng thái chờ. Tuy nhiên chương trình sẽ không bỏ trống khoảng thời gian chờ đó, chương trình sẽ tiếp tục thực hiện các câu lệnh tiếp theo. Đó là lý do Javascript là ngôn ngữ bất đồng bộ

### Câu 20: Promise và Async-Await

- Promise tức là một action mà cần thời gian để lấy data về
- Async: báo cho js là tôi muốn viết theo kiểu async - await , hay cách khác là function này là kiểu promise
- Await: tức là phải chờ cho nó lấy dữ liệu, phải có async ở đầu hàm

### Câu 21. Bind() method?

- Phương thức bind() cho phép ràng buộc this cho một phương thức (function)
- Bind() sẽ trả về một hàm mới, có thể nhận các đối số nư hàm ban đầu.
- Khi dùng phương thức Bind() thì tham số truyền vào () sẽ là đối tượng cho this, nó sẽ tạo ra một hàm mới và đối tượng là tham số này.
- Có thể mượn hàm
VD: const student = {name:'Quang', age:18}
const teacher = {
    name:'Dung, 
    age:20 ,
    getName(){
        return `${this.name} ${this.age}`
    }
}

const getStudentName = teacher.getName.bind(student) ==> Quang 18
const getTeacherName = teacher.getName.bind(teacher) ==> Dung 20

===> Nó sẽ trỏ đến đối tượng nằm trong bind() là student hay là teacher để lấy data tương ứng.

### Câu 22. Call() method?

- Call() là phương thức trong prototype của function constructor, phương thức này được dùng để gọi hàm và cũng có thể bind this cho hàm.
- Bind() và Call() khác nhau
    + Bind() là chỉ bind()
    + Còn Call() là bind()  xong rồi call() chạy hàm luôn.
- Call() có thể mượn hàm

VD: const student = {name:'Quang', age:18}
const teacher = {
    name:'Dung, 
    age:20 ,
    getName(){
        return `${this.name} ${this.age}`
    }
}

teacher.getName() ==> Dung 20
teacher.getName.call(student) ==> Quang 18
teacher.getName.call(teacher) ==> Dung 20


- Call() có tính kế thừa.

VD:  
function Animal(name, weight){
    this.name =name
    this.weight = weight
}

function Chicken(name, weight, legs){
    Animal.call(this, name, weight)
    this.legs = legs
}

const data = new Chicken('Quang', 60, 2)
console.log(data) ==> Chicken {name:'Quang', weight: 60, legs:2}

### Câu 23. Apply() method?

- Apply(): Phương thức này cho phép gọi 1 hàm với 1 this (bind) và truyền đối số cho hàm gốc dưới dạng mảng.
- Apply() có thể mượn hàm.

VD const teacher = {firstName: 'Minh', lastName:'Thu'}
function greet(greeting, message){
    return `${greeting} ${this.firstName} ${this.lastName} ${message}`
}

let result = greet.apply(teacher,['Hi', 'Xin chao'])
==> console.log(result)  ==> Hi Minh Thu Xin chao

- Tính kế thừa giống call() chỉ khác 1 thứ

VD  function Chicken(){
        Animal.call(this, argument)
        this.legs = legs
    }
hoặc có thể viết như sau:
    function Chicken(name, weight, legs){
        Animal.call(this, [name, weight])
        this.legs = legs
    }


### Câu 24. So sánh bind(), call(), apply()?

- Giống:
    + Là các method được kế thừa từ function.prototype
- Khác nhau: Các đối số và cách hoạt động.
    + Bind(): 
        - Trả ra hàm mới với `this` tham chiếu tới `thisArg`
        - Không thực hiện gọi hàm
        -Nếu được bind() kèm `arg1, arg2, ...` thì các đối số này sẽ được ưu tiên hơn.
        
        const newFn = fn.bind(thisArg, arg1, arg2, ...)
        newFn(arg1, arg2, ...)

    + Call():
        - Thực hiện bind `this` với `thisArg` và thực hiện gọi hàm
        - Nhận các đối số cho hàm gốc từ `arg1, arg2, ...`

        fn.call(thisArg, arg1, arg2, ...)

    + Apply():
        - Thực hiện bind `this` với `thisArg` và thực hiện gọi hàm
        - Nhận các đối số cho hàm gốc bằng đối số thứ 2 dưới dạng mảng `[arg1, arg2, ...]`

        fn.call(thisArg,[arg1, arg2, ...])




# D. React JS

### Câu 1: Sự khác nhau giữa Functional Component (stateless) và Class Component (stateful) trong ReactJS?

- Functional component (stateless) là hàm không có local state và cũng không có lifecycle method , vì thế cũng không có componentDidMount.
- Class component (stateful): là hàm có state, có lifecycle method

==> Chúng ta thường sẽ dùng class component khi chúng ta cần có state
==> Chúng ta sẽ dùng Functional component khi chung ta không cần có state

===> Chọn Functional component vì nó gọn hơn, dễ test hơn vì khi viết một hàm thì cái hàm nó sẽ dễ đọc hơn với input là props, output là render. Thay vì việc phải viết một cái class component có extend , có hàm render, rồi đủ thứ hàm khác nữa.


### Câu 2. Trong component khi muốn lấy dữ liệu từ server để hiển thị ra thì cái hàm lấy dữ liệu ta sẽ viết trong function nào?

- component didmount
- component didmount đc gọi sau khi được render

### Câu 3: React có gì hay mà người ta dùng nhiều vậy ?

- React có tách thành các components nên cách viết code nó sẽ tiện hơn và tính tái sử dụng rất cao.

### Câu 4. Sự khác nhau giữa Props và State?

- Props là viết tắt của Property là đối số của function và không thể thay đổi được giá trị của Props
- State là giá trị riêng của Component, và ta có thể thay đổi được giá trị của state, khi state thay đổi thì component sẽ được re-Render.

### Câu 5. kể tên một số Hook trong ReactHook?

- useState, useEffect, useReducer, useMemo, useCallback, useRef, ...

### Câu 6. FetchAPI trong React?

`
function App() {
	const [data, setData] = useState([]);

	useEffect(() => {
		// API_ENDPOINT là bất kỳ đường dẫn API nào trả về dạng JSON
		fetch("API_ENDPOINT")
			.then(response => {
				// Kiểm tra trạng thái phản hồi
				if(!response.ok) {
					throw new Error(response);
				}
				
				// Phản hồi không lỗi, trả về JSON cho then tiếp theo lấy dữ liệu
				return response.json();
			})
			.then(data => {
				// Lấy dữ liệu và setState cho data
				setData(data);
			})
			.catch(err => alert("Có lỗi"))
			.finally(() => {
				console.log("End")
			})
	}, [])
	
	return <div>Demo</demo>
}
`